# 对象

python中的一切皆对象，分为可变和不可变对象，包括三个要素：内存地址，类型，值

* `id()`对象的内存地址，唯一值，不可变
* `type()`对象类型，对象一旦创建，类型就无法更改
* `==`返回值是布尔类型，判断对象的值是否相等。对象的值是可以改变的
* `is`返回值是布尔类型，判断对象的内存地址是否相等，是否是同一个对象

**不可变对象**

数值，字符串，不可变集合，元组

**可变对象**

列表，集合，字典

*可变和不可变对象的可变是指值，内存空间不可变*

不可变对象若包含可变对象，通过改变可变对象的值，不可变对象的值也会改变

```python
a=([1,2],3,4)
print(id(a))
a[0].append(3)
print(a,id(a))

#1554920460080
#([1, 2, 3], 3, 4) 1554920460080
```

## python的赋值机制

```python
a=1
b=1
print(a==b)
print(a is b)
print(id(a),id(b))

#True
#True
#140713508590624 140713508590624
```

首先，python在内存中开辟一个空间，存储1这个对象，然后变量a,b同时指向这个内存地址，索引a,b是同一个对象，内存地址相同，值相同

但对于int来说，只有-5~256之间的数满足上述的情况。对于其他int型数字，python会开辟两个内存空间存储，所以是两个对象`==`的结果是True，`is`的结果是False

不过一般来说，赋值给多个变量会分配不同的内存地址

```python
ls1=[1]
ls2=[1]
tup1=(1,)
tup2=(1,)

print(ls1==ls2)          # True
print(ls1 is ls2)        # False
print(id(ls1),id(ls2))   # 1554920540488 1554919565256

print(tup1==tup2)        # True
print(tup1 is tup2)      # False
print(id(tup1),id(tup2)) # 1554920519608 1555023732408
```

### 赋值传递

对于不可变对象，以下面代码为例，python开辟一块内存空间存储1这个值，同时变量a指向这个地址。`b=a`并没有开辟新的内存空间，而是令b这个变量也指向该内存空间。由于是不可变对象，对a的计算不会影响原内存地址，而是开辟新的内存地址存储`a+1`的值，同时让a指向这个新地址，b不受影响；

对于可变对象，以下面代码为例，python开辟一块内存空间存储`[1]`这个列表，同时变量`l1`指向这个地址。`l2=l1`并没有开辟新的内存空间，而是令`l2`这个变量也指向该内存空间。由于是可变对象，`l1`指向的列表改变，`l2`的值也变；

```python
a=1
b=a
a+=1
print(a,b)    # 2 1

l1=[1]
l2=l1
l1.append(2)
print(l1,l2)  # [1, 2] [1, 2]
```

# 浅拷贝，深拷贝

```python
'赋值'
a=1
b=a

'拷贝'
a=[1]
b=list(a)
```

浅拷贝：重新分配内存地址，引用原对象的值。故当**引用的那部分原值**改变时，新对象的值也会改变；但若改变原对象**非引用的那部分原值**，因新对象引用的值未改变，故新对象的值不变。只有可变对象才能创建浅拷贝，不可变对象不会创建新的内存地址，新对象指向原对象的内存空间，引用原对象的值
深拷贝：新分配一个内存空间，将原对象的值递归复制给新对象，互不影响

```python
l1 = [[1,2],(3,)]
l2 = list(l1)
l3 = l1[:]
l4 = l1.copy()
print(l1)           #[[1, 2], (3,)]
print(l2,l1 is l2)  #[[1, 2], (3,)] False
print(l3,l1 is l3)  #[[1, 2], (3,)] False
print(l4,l1 is l4)  #[[1, 2], (3,)] False

"""l2,l3,l4是l1的浅拷贝，引用的是l1的前两个索引内容，
故l1新增第三个索引内容不会影响l2，l3，l4"""

l1.append(4)
print(l1)           #[[1, 2], (3,), 4]
print(l2,l1 is l2)  #[[1, 2], (3,)] False
print(l3,l1 is l3)  #[[1, 2], (3,)] False
print(l4,l1 is l4)  #[[1, 2], (3,)] False

"""l1第一个索引内容改变，引用该部分值的l2，l3，l4的值都发生改变"""

l1[0].append(0)
print(l1)           #[[1, 2, 0], (3,)]
print(l2,l1 is l2)  #[[1, 2, 0], (3,)] False
print(l3,l1 is l3)  #[[1, 2, 0], (3,)] False
print(l4,l1 is l4)  #[[1, 2, 0], (3,)] False


'''虽然l1改变的是l2引用的部分，但元组不可变，不能被浅拷贝，
所以实际上是python新开辟了内存空间存储新值，同时这个新的内存地址指向l1，
原来的内存地址不再指向l1，也没有改变，引用该值的l2的也没有变'''

l1[1] = (3,4)
print(l1)           #[[1, 2], (3, 4)]
print(l2,l1 is l2)  #[[1, 2], (3,)] False
print(l3,l1 is l3)  #[[1, 2], (3,)] False
print(l4,l1 is l4)  #[[1, 2], (3,)] False

```

可见，浅拷贝会造成数据改变，可以使用深拷贝

```python
import copy
l1 = [[1,2],(3,)]
l2 = copy.deepcopy(l1)
print(l1)             # [[1, 2], (3,)]
print(l2,l1 is l2)    # [[1, 2], (3,)] False
l1[0].append(4)
print(l1)             # [[1, 2, 4], (3,)]
print(l2,l1 is l2)    # [[1, 2], (3,)] False
```